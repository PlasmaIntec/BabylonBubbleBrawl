<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="babylonjs/pep.min.js"></script>
        <script src="babylonjs/dat.gui.min.js"></script>
        <script src="babylonjs/ammo.js"></script>
        <script src="babylonjs/cannon.js"></script>
        <script src="babylonjs/Oimo.js"></script>
        <script src="babylonjs/earcut.min.js"></script>
        <script src="babylonjs/babylon.js"></script>
        <script src="babylonjs/babylon.inspector.bundle.js"></script>
        <script src="babylonjs/babylonjs.materials.min.js"></script>
        <script src="babylonjs/babylonjs.proceduralTextures.min.js"></script>
        <script src="babylonjs/babylonjs.postProcess.min.js"></script>
        <script src="babylonjs/babylonjs.loaders.js"></script>
        <script src="babylonjs/babylonjs.serializers.min.js"></script>
        <script src="babylonjs/babylon.gui.min.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
	<canvas id="renderCanvas"></canvas>
	<script src="helpers.js"></script>
	<script src="meshGenerators.js"></script>
	<script src="interactions.js"></script>
	<script>
		var canvas = document.getElementById("renderCanvas");

		var engine = null;
		var scene = null;
		var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
		var createScene = function () {
			
			// Scene
			var scene = new BABYLON.Scene(engine);			

			// Physics engine
			scene.enablePhysics(null, new BABYLON.CannonJSPlugin());
			scene.getPhysicsEngine().setGravity(BABYLON.Vector3.Zero());
			var physicsViewer = new BABYLON.Debug.PhysicsViewer();
			var physicsHelper = new BABYLON.PhysicsHelper(scene);
			
			// Camera
			var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 200, new BABYLON.Vector3(0, 0, 0), scene);
			camera.attachControl(canvas, true);

			// Light
			var light = new BABYLON.PointLight("omni", new BABYLON.Vector3(0, 50, 0), scene);

			// Glow
			var gl = new BABYLON.GlowLayer("glow", scene);
			gl.intensity = 10;

			makeGround(scene);
			var sphere = makeBasicShooter(scene, 0, 20, 0, 5, BABYLON.Color3.Green());
			window.sphere = sphere;
			sphere.aimDirection = new BABYLON.Vector3(1,0,0);
			for (var x = 20; x < 40; x += 4) {
				for (var y = 10; y < 30; y += 4) {
					for (var z = -40; z < 40; z += 4) {
						makeSphereWithPhysics(scene, x, y, z, 2, BABYLON.Color3.Red());
					}
				}
			}

			addKeyboardInteractions(scene, sphere, physicsHelper)

			// Mouse
			var mousemovef = (object) => {
				var pickResult = scene.pick(scene.pointerX, scene.pointerY);

				if (pickResult.hit) {
					var diffX = pickResult.pickedPoint.x - object.position.x;
					var diffY = pickResult.pickedPoint.z - object.position.z;
					object.rotation = new BABYLON.Vector3(0, Math.atan2(diffX,diffY), 0);
				}	
			}

			scene.onPointerMove = () => {
				mousemovef(sphere);
			};

			var vecToLocal = (vector, mesh) => {
				var m = mesh.getWorldMatrix();
				var v = BABYLON.Vector3.TransformCoordinates(vector, m);
				return v;		 
			}

			var castRay = (object) => {      
				var origin = object.position;
				var pickResult = scene.pick(scene.pointerX, scene.pointerY);

				if (pickResult.hit && pickResult.pickedMesh.id == "ground") {
					var pickX = pickResult.pickedPoint.x;
					var pickZ = pickResult.pickedPoint.z;
					var forward = new BABYLON.Vector3(pickX, object.position.y, pickZ);	
				} else {
					return
				}
				
				var direction = forward.subtract(origin);
				direction = BABYLON.Vector3.Normalize(direction);
				object.aimDirection = direction;
			
				var length = 100;
			
				var ray = new BABYLON.Ray(origin, direction, length);
				var rayHelper = new BABYLON.RayHelper(ray);
				rayHelper.show(scene);

				return rayHelper;
			}

			// Animations
			var time = 0;
			var prevRay;
			scene.registerBeforeRender(function () {
				bullets.forEach(bullet => bullet.position = bullet.position.add(sphere.aimDirection.scale(.5)));
				sphere.physicsImpostor.setLinearVelocity(sphere.physicsImpostor.getLinearVelocity().scale(.99))
				gl.intensity = Math.cos(time) + 1;
				if (prevRay) prevRay.hide(scene);
				prevRay = castRay(sphere);
				time += .1;
			});

			return scene;
		}

		engine = createDefaultEngine();
		if (!engine) throw 'engine should not be null.';
		scene = createScene();

		engine.runRenderLoop(function () {
			if (scene) {
				scene.render();
			}
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});
	</script>
</body>
</html>
