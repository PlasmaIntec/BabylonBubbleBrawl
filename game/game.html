<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="babylonjs/pep.min.js"></script>
        <script src="babylonjs/dat.gui.min.js"></script>
        <script src="babylonjs/ammo.js"></script>
        <script src="babylonjs/cannon.js"></script>
        <script src="babylonjs/Oimo.js"></script>
        <script src="babylonjs/earcut.min.js"></script>
        <script src="babylonjs/babylon.js"></script>
        <script src="babylonjs/babylon.inspector.bundle.js"></script>
        <script src="babylonjs/babylonjs.materials.min.js"></script>
        <script src="babylonjs/babylonjs.proceduralTextures.min.js"></script>
        <script src="babylonjs/babylonjs.postProcess.min.js"></script>
        <script src="babylonjs/babylonjs.loaders.js"></script>
        <script src="babylonjs/babylonjs.serializers.min.js"></script>
        <script src="babylonjs/babylon.gui.min.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
	<canvas id="renderCanvas"></canvas>
	<script src="helpers.js"></script>
	<script src="meshGenerators.js"></script>
	<script src="interactions.js"></script>
	<script src="mapTraversal.js"></script>
	<script src="evolution.js"></script>
	<script>
		var canvas = document.getElementById("renderCanvas");

		var engine = null;
		var scene = null;
		var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
		var createScene = function () {
			
			// Scene
			var scene = new BABYLON.Scene(engine);	
			scene.actionManager = new BABYLON.ActionManager(scene);		

			// Physics engine
			scene.enablePhysics(null, new BABYLON.CannonJSPlugin());
			scene.getPhysicsEngine().setGravity(BABYLON.Vector3.Zero());
			var physicsViewer = new BABYLON.Debug.PhysicsViewer();
			var physicsHelper = new BABYLON.PhysicsHelper(scene);
			
			// Camera
			var camera = new BABYLON.UniversalCamera("Camera", new BABYLON.Vector3(0, 200, 0), scene);
			camera.rotation = new BABYLON.Vector3(Math.PI/2, Math.PI*3/2, 0);
			camera.attachControl(canvas, true);
			
			// GUI
			var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

			var healthText = new BABYLON.GUI.InputText();
			healthText.width = "150px"
			healthText.height = "40px";
			healthText.color = "white";
			healthText.cornerRadius = 20;
			healthText.background = "green";
			healthText.left = "-400px";
			healthText.top = "330px";

			var experienceText = new BABYLON.GUI.InputText();
			experienceText.width = "150px"
			experienceText.height = "40px";
			experienceText.color = "white";
			experienceText.cornerRadius = 20;
			experienceText.background = "purple";
			experienceText.left = "-400px";
			experienceText.top = "380px";
			
			var evolutions = [
				["speed", "yellow"],
				["power", "red"],
				["health", "orange"],
			]
			var evolutionButtons = [];

			evolutions.forEach((evolution, index) => {
				var [name, color] = evolution;
				var button = BABYLON.GUI.Button.CreateSimpleButton(name, name);
				button.width = "60px"
				button.height = "40px";
				button.left = "-400px";
				button.top = `${280 - 50*index}px`
				button.color = "white";
				button.background = color;
				button.isVisible = false;
				button.action = () => console.log(name)
				evolutionButtons.push(button);
				advancedTexture.addControl(button);   
			})
			
			advancedTexture.addControl(healthText);  
			advancedTexture.addControl(experienceText);   
			
			var health = 100;
			var updateHealthText = health => {
				healthText.text = `hp: ${health}`;
			}
			var subtractHealth = subtract => {
				health -= subtract;
				updateHealthText(health);
				return health;
			}
			updateHealthText(health); 
			
			var experience = 0;
			var updateExperienceText = experience => {
				experienceText.text = `exp: ${experience}`;
			}
			var addExperience = add => {
				experience += add;
				updateExperienceText(experience);
				return experience;
			}
			updateExperienceText(experience);

			// Light
			var light = new BABYLON.PointLight("omni", new BABYLON.Vector3(0, 50, 0), scene);

			// Glow
			var gl = new BABYLON.GlowLayer("glow", scene);
			gl.intensity = 10;

			// Scene Elements
			var location = { x: 0, z: 0 };
			var gridSize = 100;
			var sphere = makeBasicShooter(scene, 0, 20, 0, 5, BABYLON.Color3.Green());
			window.sphere = sphere; // DELETE
			var gridElements = [];
			sphere.aimDirection = new BABYLON.Vector3(1,0,0);
			for (var x = 20; x < 40; x += 4) {
				for (var y = 10; y < 30; y += 4) {
					for (var z = -40; z < 40; z += 4) {
						var debris = makeSphereWithPhysics(scene, x, y, z, 2, BABYLON.Color3.Red());
						gridElements.push(debris);
					}
				}
			}
			var enemies = [];
			generateNewGrid(location, gridSize, gridElements, enemies, physicsHelper);

			var map = {}; // object for multiple key presses
			addKeyboardInteractions(scene, sphere, physicsHelper, map)

			// Mouse
			var mousemovef = (object) => {
				var pickResult = scene.pick(scene.pointerX, scene.pointerY);

				if (pickResult.hit) {
					object.rotation = getAnglePointingAt(pickResult.pickedPoint, object.position);
				}	
			}

			scene.onPointerMove = () => {
				mousemovef(sphere);
			};

			var vecToLocal = (vector, mesh) => {
				var m = mesh.getWorldMatrix();
				var v = BABYLON.Vector3.TransformCoordinates(vector, m);
				return v;		 
			}

			var castRay = (object) => {      
				var origin = object.position;
				var pickResult = scene.pick(scene.pointerX, scene.pointerY);

				if (pickResult.hit && pickResult.pickedMesh.id == "ground") {
					var pickX = pickResult.pickedPoint.x;
					var pickZ = pickResult.pickedPoint.z;
					var forward = new BABYLON.Vector3(pickX, object.position.y, pickZ);	
				} else {
					return
				}
				
				var direction = forward.subtract(origin);
				direction = BABYLON.Vector3.Normalize(direction);
				object.aimDirection = direction;
			
				var length = 100;
			
				var ray = new BABYLON.Ray(origin, direction, length);
				var rayHelper = new BABYLON.RayHelper(ray);
				rayHelper.show(scene);

				return rayHelper;
			}

			// Animations
			var time = 0;
			var prevRay;
			var speed = 10;
			var stillPlaying = false;
			scene.registerBeforeRender(function () {
				bullets.forEach(bullet => {
					bullet.position = bullet.position.add(BABYLON.Vector3.Normalize(bullet.direction));
					if (bullet.isFriendly) {
						enemies.forEach(enemy => {
							if (bullet.intersectsMesh(enemy, false)) {
								bullet.cancel();
								bullets.pop(bullet.bulletIndex);
								if (enemy.takeDamage(20)) { // enemy dies
									enemies.pop(enemy.enemyIndex);
									if (addExperience(1) > 0) {
										evolutionButtons.forEach(button => {
											button.isVisible = true
											button.onPointerClickObservable.add(() => {
												button.action();
												evolutionButtons.forEach(button => button.isVisible = false);
											})
										})
									}
								}
							}
						})
					} else if (bullet.intersectsMesh(sphere, false)) {
						subtractHealth(10);
						bullet.cancel();
						bullets.pop(bullet.bulletIndex);
					}
				});
				enemies.forEach(enemy => enemy.passiveMove(sphere));
				sphere.physicsImpostor.setLinearVelocity(sphere.physicsImpostor.getLinearVelocity().scale(.99))
				gl.intensity = Math.cos(time) + 1;
				if (prevRay) prevRay.hide(scene);
				prevRay = castRay(sphere);
				
				if (map["w"] || map["W"]) {
					pulse(sphere, new BABYLON.Vector3(-speed, 0, 0));
				}
				
				if ((map["a"] || map["A"])) {
					pulse(sphere, new BABYLON.Vector3(0, 0, -speed));
				}
				
				if ((map["s"] || map["S"])) {
					pulse(sphere, new BABYLON.Vector3(speed, 0, 0));
				}
				
				if ((map["d"] || map["D"])) {
					pulse(sphere, new BABYLON.Vector3(0, 0, speed));
				}

				if (!stillPlaying && outOfGrid(sphere, location, gridSize)) {
					stillPlaying = true;
					var movementDirection = getMovementDirection(sphere, location, gridSize);
					var movementMagnitude = 100;
					moveLocation(movementDirection.x * movementMagnitude, movementDirection.z * movementMagnitude, camera, location, gridSize)
					.then(() => {
						stillPlaying = false;
						location.x += movementDirection.x;
						location.z += movementDirection.z;
						// destroy previous grid
						gridElements.forEach(e => e.dispose());
						enemies.forEach(e => e.cancelActions());
						bullets.forEach(e => e.cancel());
						// procedurally generate new grid
						generateNewGrid(location, gridSize, gridElements, enemies, physicsHelper);
					})
				}

				time += .1;
			});		

			return scene;
		}

		engine = createDefaultEngine();
		if (!engine) throw 'engine should not be null.';
		scene = createScene();

		engine.runRenderLoop(function () {
			if (scene) {
				scene.render();
			}
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});
	</script>
</body>
</html>
